# 다이나믹 프로그래밍

[강의 링크](https://www.youtube.com/watch?v=5Lu34WIx2Us&list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC&index=6)

## 다이나믹 프로그래밍이란?

- 보통은 연산속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘을 작성해야함
- 하지만 어떤 문제는 메모리를 약간 더 사용하면 속도를 비약적으로 증가시킬 수 있다
- 이렇게 메모리를 적절히 사용하여 수행 시간 효율성을 증가시키는게 다이나믹 프로그래밍
- 동적 계획법
- 동적(dynamic)이란?
  - 자료구조: 프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법
  - 알고리즘: 별다른 의미없이 사용

## 다이나믹 프로그래밍의 조건

1. 최적 부분 구조 (Optimal Substructure)

- 큰 문제를 작은 문제로 나눌 수 있거나
- 작은 문제의 답을 모아서 큰 문제로 해결 가능할때

2. 중복되는 부분 문제 (Overlapping Subproblem)

- 동일한 작은 문제를 반복적으로 해결

### 피보나치 수열

1. fibo 재귀함수

```python
def fibo(x):
    if x == 1 or x==2:
        return 1
    return fibo(x-1)+fibo(x-2)

print(fibo(4))
```

- 재귀함수를 사용하면 지수 시간 복잡도를 가지게 됨
- 비효율적
- 피보나치는 네번째 피보나치 수를 구하는건 세번째수와 두번째수를 더한 값이다. (최적 부분 구조: 큰 문제를 해결하기 위해 작은 문제 두개를 해결한 값을 가지고 있으면 됨)
- 네번째 피보나치수를 구할 때에도 두 번째 피보나치 수는 두 번 호출됨 (중복되는 부분 문제: 하나의 큰 문제가 해결되는 과정에서 동일한 작은 문제가 반복적으로 해결될 수 있도록 요구됨)

### DP 구현 방법

1. 하향식 top-down (메모이제이션)

- 한 번 계산된 결과를 메모리 공간에 메모하는 기법
- 같은 문제가 다시 호출되면 메모를 가져옴
- 배열에 값을 기록
- 캐싱이라고도 함수
- 구현 과정에서 "재귀함수를 사용"한다: 큰 문제를 해결하기 위해서 작은 문제들을 재귀적으로 호출하여 작은 문제가 모두 해결되었을 때, 실제로 큰 문제에 대한 답까지 얻을 수 있도록 코드를 작성 + 한 번 계산된 결과 값을 저장해놓기 위해 메모이제이션 사용

2. 상향식 bottom-up

- 아래쪽에서부터 작은 문제를 하나씩 해결해나가면서 먼저 계산했던 문제들의 값을 활용해서 그 다음의 문제까지 차례대로 해결
- "반복문 사용"
- DP의 전형적인 형태
- 결과저장용 리스트는 DP table

3. fibo DP - 하향식 top-down (메모이제이션)

- 시간 복잡도 : O(N)

```python
d = [0]*100 #한 번 계산 된 결과를 메모이 제이션하기 위한 리스트 초기화

def fibo(x):
    if x==1 or x==2: #종료조건
        return 100
    if d[x]!=0: #(중요)이미 계산된적있다면 바로 그 값을 리턴
        return d[x]
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]

print(fibo(99))
```

4. fibo DP - 상향식 bottom-up

```python
d = [0]*100 #한 번 계산 된 결과를 메모이 제이션하기 위한 리스트 초기화

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n+1): #작은문제를 먼저해결 -> 조합해서 앞으로의 큰문제해결(차례대로)
    d[i] = d[i-1]+d[i-2]

return d[n]

```
